#!/usr/bin/env ruby

#==============================================================================
# Author:            Tom Henderson
# Acknowledgements:  
# Organization:      NCAR MMM
#
# Description:  
#
#   This is an application that finds all symbols that match a specified 
#   String in all Fortran source files beneath a specified directory.  
#
#   Type "ruby findSymbol.rb -h" for command-line options.  
#
#
# Assumptions:  
#   Source code is in Fortran90/95 free form.  
#   Source code compiles.  
#
#
# History:  
#
#  Version 0.1  - Initial alpha-test version.  
#
#==============================================================================

# classes used by this class
require 'optparse'
require 'find'
require 'fortranStatements'


#==============================================================================
# Responsible for:  
#   Translating all files beneath a specified directory to use a specified 
#   kind.  
#   Parsing command-line arguments.  
#==============================================================================
class FindSymbol

  attr_reader :fileName

  @@verbose_off = 0
  @@verbose_min = 1
  @@verbose_max = 2

  # FindSymbol.new
  def initialize
    # default settings
    @targetdir = nil
    @symbol = nil
    @verbose = @@verbose_off
    @appname = File.basename($0)
    @helpmsg = "\nType \"ruby #{@appname} -h\" for help\n\n"
    @skip_files = []
    @public = false
    @operators = false
    @new_symbol = nil
    @new_module = nil
    @old_module = nil
    if (parse_command_line) then
      search_source_files
    else
      print "ERROR:  could not parse arguments\n#{@helpmsg}"
      exit -1
    end
  end

  # returns true iff command line was successfully parsed
  def parse_command_line
    ret = true
    # Use OptionParser from standard library
    opts = OptionParser.new do |opts|
      opts.banner = <<END_OF_BANNER

#{@appname} is an application that finds all symbols that match a specified 
String in all Fortran source files beneath a specified directory.  All 
matching symbols are sorted and duplicates are removed.  

Fortran source files must contain valid free-form source code that is free 
from syntax errors.  #{@appname} does not understand cpp directives and will ignore 
them, when possible.  

Usage:  ruby #{@appname} arguments [options]
END_OF_BANNER
      opts.separator ""
      opts.separator "Required arguments:"
      # Mandatory arguments.
      opts.on("-d=DIR", "--directory=DIR",
              "Translate all files in the directory tree rooted at DIR") do |dir|
        absdir = dir.strip.sub("/$","")
        unless (FileTest.directory?(absdir)) then
          print "\nERROR:  \"#{absdir}\" is not a valid directory\n#{@helpmsg}"
          exit -1
        end
        @targetdir = absdir
      end
      opts.separator ""
      opts.separator "Specific options:"
      # search symbol
      opts.on("-S=SYMBOL", "--Symbol=SYMBOL",
              "Find all symbols that match SYMBOL") do |sym|
        @symbol = sym
      end
      # generate module that translates SYMBOL to NEW_SYMBOL
      opts.on("-g=NEW_SYMBOL", "--generate_module=NEW_SYMBOL",
              "Generate module that translates all occurrences of SYMBOL to NEW_SYMBOL") do |sym|
        @new_symbol = sym
      end
      # old module name used when generating module that translates SYMBOL to NEW_SYMBOL
      opts.on("-o=OLD_MODULE", "--old_module_name=OLD_MODULE",
              "Name of old module in module generated by -g.  -o must be used whenever -g is used.") do |name|
        @old_module = name
      end
      # new module name used when generating module that translates SYMBOL to NEW_SYMBOL
      opts.on("-n=NEW_MODULE", "--new_module_name=NEW_MODULE",
              "Name of new module generated by -g.  -n must be used whenever -g is used.") do |name|
        @new_module = name
      end
      # directories and files to skip
      opts.on("-s dir1,dir2,dir3", "--skip_files dir1,file2,dir3", Array, 
              "Skip directories and files specified in comma-separated list") do |filelist|
        @skip_files = filelist
#        @skip_files = filelist.split(",")
      end
      # only include symbols appearing in PUBLIC statements or whose 
      # declarations include the PUBLIC attribute
      opts.on("-O", "--Operators", 
              "Also include all Fortran keywords \"operator\" and \"assignment\" along with matched symbols") do
        @operators = true
      end
      # only include symbols appearing in PUBLIC statements or whose 
      # declarations include the PUBLIC attribute
      opts.on("-p", "--public", 
              "Only include symbols that appear in a PUBLIC statement or whose declarations include the PUBLIC attribute") do
        @public = true
      end
      # verbosity
      opts.on("-v=MESSAGE_LEVEL", "--verbose=MESSAGE_LEVEL", 
              "Run verbosely\n    MESSAGE_LEVEL=0 -> no-verbose (default)\n    MESSAGE_LEVEL=1 -> verbose\n    MESSAGE_LEVEL=2 -> loquacious") do |v|
        @verbose = v.to_i
      end
      # No argument, shows at tail.  This will print an options summary.
      opts.on_tail("-h", "--help", "Show this message\n") do
        puts opts
        exit
      end
    end
    begin
      opts.parse!(ARGV)
    rescue
#raise
      ret = false
    end
    unless (@targetdir) then
      print "\nERROR:  Must specify target directory on command line\n"
      ret = false
    end
    if (@symbol) then
      if (@symbol =~ /\W+/) then
        print "\nERROR:  Symbol <<#{@symbol}>> must consist of characters that are valid in a Fortran variable name.\n"
        ret = false
      end
    else
      print "\nERROR:  Must specify search symbol on command line\n"
      ret = false
    end
    if (@new_symbol) then
      if (@new_symbol =~ /\W+/) then
        print "\nERROR:  New symbol <<#{@new_symbol}>> must consist of characters that are valid in a Fortran variable name.\n"
        ret = false
      end
      if (@new_module.nil?) then
        print "\nERROR:  New module must be specified using \"-n\" whenever \"-g\" is used.\n"
        ret = false
      else
        if (@new_module =~ /\W+/) then
          print "\nERROR:  New module <<#{@new_module}>> must consist of characters that are valid in a Fortran variable name.\n"
          ret = false
        end
      end 
      if (@old_module.nil?) then
        print "\nERROR:  Old module must be specified using \"-n\" whenever \"-g\" is used.\n"
        ret = false
      else
        if (@old_module =~ /\W+/) then
          print "\nERROR:  Old module <<#{@old_module}>> must consist of characters that are valid in a Fortran variable name.\n"
          ret = false
        end
      end 
    end
    ret
  end

  def search_source_files
    matching_symbols = []
    pubstr = ""
    opstr = ""
    if (@public) then
      pubstr = "public "
    end
    if (@operators) then
      opstr = "Fortran keywords \"operator\" and \"assignment\" will also be included.\n"
    end
    if (@verbose >= @@verbose_min) then
      print "\n#{@appname}:  Searching for all #{pubstr}symbols matching \"#{@symbol}\" in all Fortran source files in directory \"#{@targetdir}\".\n#{opstr}\n"
    end
    unless (@skip_files.empty?) then
      if (@verbose >= @@verbose_min) then
        print "\n#{@appname}:  Skipping these sub-directories and files:  \"#{@skip_files.join("\" \"")}\"\n\n"
      end
    end
    foundfile = false
    Find.find(@targetdir) do |f|
      # skip directories and files
      skipit = false
      @skip_files.each do |skipfile|
        if ((f =~ /\/#{skipfile}\//) or (f =~ /\/#{skipfile}$/)) then
          skipit = true
        end
      end
#$$$DEBUG
#if (skipit) then
#  print "DEBUG:  skipping file <<#{f}>>\n"
#end
#$$$END DEBUG
      Find.prune if skipit
      # search Fortran source files
      if (f =~ /\.(f$|f90$)/i) then
#$$$DEBUG
#print "DEBUG:  Searching Fortran source file \"#{f}\"...\n"
#if (false) then
#$$$END DEBUG
        foundfile = true
        if (@verbose >= @@verbose_min) then
          print "#{@appname}:  Searching Fortran source file \"#{f}\"...\n"
        end
        statements = FortranStatements.new(f, @verbose == @@verbose_max)
        matching_symbols = matching_symbols + statements.findSymbols(@symbol, @public, @operators)
#$$$DEBUG
#end
#$$$END DEBUG
      end
    end
    if (foundfile) then
      matching_symbols.sort!
      matching_symbols.uniq!
      unless (matching_symbols.empty?) then
        if (@verbose >= @@verbose_min) then
          print "Found #{matching_symbols.length} #{pubstr}matching symbols:\n"
        end
        if (@new_symbol) then
          # print out translation module
          comment_str = <<END_OF_COMMENTS
! 
! WARNING:  This file was automatically generated by the #{@appname} script. 
! 
END_OF_COMMENTS
          print comment_str
          print "MODULE #{@new_module}\n\n"
          matching_symbols.each do |sym|
            if (sym =~ /#{@symbol}/i) then
              new_name = sym.sub(/#{@symbol}/i,@new_symbol)
              print "  USE #{@old_module}, only: #{new_name} => #{sym}\n"
            else
              # handle "operator", "assignment", etc.
              print "  USE #{@old_module}, only: #{sym}\n"
            end
          end
          print "\n  IMPLICIT NONE\n\n"
#          print "  PRIVATE\n\n"
          print "END MODULE #{@new_module}\n"
        else
          # default behavior is to print out matching symbols
          print "#{matching_symbols.join("\n")}\n"
        end
      else
        if (@verbose >= @@verbose_min) then
          print "Found no matching symbols!\n"
        end
      end
    else
      if (@verbose >= @@verbose_min) then
        print "\nWARNING:  Could not find any Fortran source files to search in directory \"#{@targetdir}\""
      end
    end
  end

end  # class FindSymbol


# FindSymbol.new


