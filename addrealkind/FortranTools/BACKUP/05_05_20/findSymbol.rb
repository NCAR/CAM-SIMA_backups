#!/usr/bin/env ruby

#==============================================================================
# Author:            Tom Henderson
# Acknowledgements:  
# Organization:      NCAR MMM
#
# Description:  
#
#   This is an application that finds all symbols that match a specified 
#   String in all Fortran source files beneath a specified directory.  
#   Fortran character literals, FORMAT statements, and comments are avoided.  
#   The symbols may be optionally modified in-place.  
#   A Fortran module that translates symbol names may optionally be 
#   generated.  
#
#   Type "ruby findSymbol.rb -h" for command-line options.  
#
#
# Assumptions:  
#   Source code is in Fortran90/95 free form.  
#   Source code compiles.  
#
#
# History:  
#
#  Version 0.1  - Initial alpha-test version.  
#
#==============================================================================

# classes used by this class
require 'optparse'
require 'find'
require 'fortranStatements'


#==============================================================================
# Responsible for:  
#   Finding all symbols that match a specified 
#   String in all Fortran source files beneath a specified directory.  
#   Optionally modifying symbols in-place.  
#   Optionally generating a Fortran module that translates symbol names.  
#   Parsing command-line arguments.  
#==============================================================================
class FindSymbol

  attr_reader :fileName

  @@verbose_off = 0
  @@verbose_min = 1
  @@verbose_max = 2

  # FindSymbol.new
  def initialize
    # default settings
    @targetdir = nil
    @symbol = nil
    @verbose = @@verbose_off
    @appname = File.basename($0)
    @helpmsg = "\nType \"ruby #{@appname} -h\" for help\n\n"
    @skip_files = []
    @public = false
    @operators = false
    @new_symbol = nil
    @new_module = nil
    @old_module = nil
    @replacement = nil
    @stdout_fname = nil
    if (parse_command_line) then
      search_source_files
    else
      print "ERROR:  could not parse arguments\n#{@helpmsg}"
      exit -1
    end
  end

  # returns true iff command line was successfully parsed
  def parse_command_line
    ret = true
    # Use OptionParser from standard library
    opts = OptionParser.new do |opts|
      opts.banner = <<END_OF_BANNER

#{@appname} is an application that finds all symbols that match a specified 
String in all Fortran source files beneath a specified directory.  All 
matching symbols are sorted and duplicates are removed.  Symbols inside 
character string literals or in Fortran FORMAT statements are ignored.  

Fortran character literals, FORMAT statements, and comments are avoided.  
The symbols may be optionally modified in-place.  A Fortran module that 
translates symbol names may optionally be generated.  

Fortran source files must contain valid free-form source code that is free 
from syntax errors.  #{@appname} does not understand cpp directives and will ignore 
them, when possible.  

Usage:  ruby #{@appname} arguments [options]
END_OF_BANNER
      opts.separator ""
      opts.separator "Required arguments:"
      # Mandatory arguments.
      opts.on("-d=DIR", "--directory=DIR",
              "Translate all files in the directory tree rooted at DIR") do |dir|
        absdir = dir.strip.sub("/$","")
        unless (FileTest.directory?(absdir)) then
          print "\nERROR:  \"#{absdir}\" is not a valid directory\n#{@helpmsg}"
          exit -1
        end
        @targetdir = absdir
      end
      opts.separator ""
      opts.separator "Specific options:"
      # search symbol
      opts.on("-S=SYMBOL", "--Symbol=SYMBOL",
              "Find all symbols that match SYMBOL") do |sym|
        @symbol = sym
      end
      # generate module that translates SYMBOL to NEW_SYMBOL
      opts.on("-g=NEW_SYMBOL", "--generate_module=NEW_SYMBOL",
              "Generate module that translates all occurrences of SYMBOL to NEW_SYMBOL") do |sym|
        @new_symbol = sym
      end
      # old module name used when generating module that translates SYMBOL to NEW_SYMBOL
      opts.on("-o=OLD_MODULE", "--old_module_name=OLD_MODULE",
              "Name of old module in module generated by -g.  -o must be used whenever -g is used.") do |name|
        @old_module = name
      end
      # new module name used when generating module that translates SYMBOL to NEW_SYMBOL
      opts.on("-n=NEW_MODULE", "--new_module_name=NEW_MODULE",
              "Name of new module generated by -g.  -n must be used whenever -g is used.") do |name|
        @new_module = name
      end
      # directories and files to skip
      opts.on("-s dir1,dir2,dir3", "--skip_files dir1,file2,dir3", Array, 
              "Skip directories and files specified in comma-separated list") do |filelist|
        @skip_files = filelist
#        @skip_files = filelist.split(",")
      end
      # redirection of stdout exclusive of "verbose" output
      opts.on("-w=OUTPUT_FILE", "--write_to_file=OUTPUT_FILE",
              "Write matching symbols or translation module OUTPUT_FILE instead of stdout.  Note that optional output due to the \"verbose\" option is not included.") do |filename|
        @stdout_fname = filename
      end
      # only include symbols appearing in PUBLIC statements or whose 
      # declarations include the PUBLIC attribute
      opts.on("-O", "--Operators", 
              "Also include all Fortran keywords \"operator\" and \"assignment\" along with matched symbols") do
        @operators = true
      end
      # replace symbol with new string modifying searched files on-the-fly
      opts.on("-R=REPLACEMENT_STRING", "--Replace_symbol=REPLACEMENT_STRING",
              "Replace all occurrences of SYMBOL with REPLACEMENT_STRING, modifying searched files on-the-fly.  Found symbols are not echoed.") do |repl|
        @replacement = repl
      end
      # only include symbols appearing in PUBLIC statements or whose 
      # declarations include the PUBLIC attribute
      opts.on("-p", "--public", 
              "Only include symbols that appear in a PUBLIC statement or whose declarations include the PUBLIC attribute") do
        @public = true
      end
      # verbosity
      opts.on("-v=MESSAGE_LEVEL", "--verbose=MESSAGE_LEVEL", 
              "Run verbosely\n    MESSAGE_LEVEL=0 -> no-verbose (default)\n    MESSAGE_LEVEL=1 -> verbose\n    MESSAGE_LEVEL=2 -> loquacious") do |v|
        @verbose = v.to_i
      end
      # No argument, shows at tail.  This will print an options summary.
      opts.on_tail("-h", "--help", "Show this message\n") do
        puts opts
        exit
      end
    end
    begin
      opts.parse!(ARGV)
    rescue
#raise
      ret = false
    end
    unless (@targetdir) then
      print "\nERROR:  Must specify target directory on command line\n"
      ret = false
    end
    if (@symbol) then
      if (@symbol =~ /\W+/) then
        print "\nERROR:  Symbol <<#{@symbol}>> must consist of characters that are valid in a Fortran variable name.\n"
        ret = false
      end
    else
      print "\nERROR:  Must specify search symbol on command line\n"
      ret = false
    end
    if (@new_symbol) then
      if (@new_symbol =~ /\W+/) then
        print "\nERROR:  New symbol <<#{@new_symbol}>> must consist of characters that are valid in a Fortran variable name.\n"
        ret = false
      end
      if (@new_module.nil?) then
        print "\nERROR:  New module must be specified using \"-n\" whenever \"-g\" is used.\n"
        ret = false
      else
        if (@new_module =~ /\W+/) then
          print "\nERROR:  New module <<#{@new_module}>> must consist of characters that are valid in a Fortran variable name.\n"
          ret = false
        end
      end 
      if (@old_module.nil?) then
        print "\nERROR:  Old module must be specified using \"-n\" whenever \"-g\" is used.\n"
        ret = false
      else
        if (@old_module =~ /\W+/) then
          print "\nERROR:  Old module <<#{@old_module}>> must consist of characters that are valid in a Fortran variable name.\n"
          ret = false
        end
      end 
    end
    ret
  end

  def search_source_files
    matching_symbols = []
    pubstr = ""
    if (@public) then
      pubstr = "public "
    end
    opstr = ""
    if (@operators) then
      opstr = "Fortran keywords \"operator\" and \"assignment\" will also be included.\n"
    end
    replstr = ""
    if (@replacement) then
      replstr = "Symbol #{@symbol} will be replaced by #{@replacement} modifying Fortran source files in place.\n"
    end
    if (@verbose >= @@verbose_min) then
      print "\n#{@appname}:  Searching for all #{pubstr}symbols matching \"#{@symbol}\" in all Fortran source files in directory \"#{@targetdir}\".\n#{opstr}#{replstr}\n"
    end
    unless (@skip_files.empty?) then
      if (@verbose >= @@verbose_min) then
        print "\n#{@appname}:  Skipping these sub-directories and files:  \"#{@skip_files.join("\" \"")}\"\n\n"
      end
    end
    foundfile = false
    Find.find(@targetdir) do |f|
      # skip directories and files
      skipit = false
      @skip_files.each do |skipfile|
        if ((f =~ /\/#{skipfile}\//) or (f =~ /\/#{skipfile}$/)) then
          skipit = true
        end
      end
#$$$DEBUG
#if (skipit) then
#  print "DEBUG:  skipping file <<#{f}>>\n"
#end
#$$$END DEBUG
      Find.prune if skipit
      # search Fortran source files
      if (f =~ /\.(f$|f90$)/i) then
#$$$DEBUG
#print "DEBUG:  Searching Fortran source file \"#{f}\"...\n"
#if (false) then
#$$$END DEBUG
        foundfile = true
        if (@verbose >= @@verbose_min) then
          print "#{@appname}:  Searching Fortran source file \"#{f}\"...\n"
        end
        statements = FortranStatements.new(f, @verbose == @@verbose_max)
        matching_symbols = matching_symbols + statements.findSymbols(@symbol, @public, @operators)
        # replace symbol overwriting input file
#$$$ remove this duplication with addRealKind
        if (@replacement) then
          # temporary backup file
          backupfile = "#{f}.BACKUP.#{$$}"
          File.rename(f, backupfile)
          begin
            # overwrite input file
            File.open(f, "w") do |aFile|
              aFile.puts(statements.replaceSymbols(@symbol, @replacement))
            end   # File.open
          rescue
            # restore original file on exception
            File.delete(f)
            File.rename(backupfile, f)
            raise
          end
          File.delete(backupfile)
        end
#$$$DEBUG
#end
#$$$END DEBUG
      end
    end
    # print out symbol list or translation module if "-R" was not specified
    if (@replacement.nil?) then
      if (foundfile) then
        matching_symbols.sort!
        matching_symbols.uniq!
        unless (matching_symbols.empty?) then
          if (@verbose >= @@verbose_min) then
            print "Found #{matching_symbols.length} #{pubstr}matching symbols:\n"
          end
          if (@stdout_fname) then
            # @stdout_fname is overwritten if it already exists
            ios = File.new("#{@stdout_fname}", "w") 
          else
            ios = $stdout
          end
          if (@new_symbol) then
            # print out translation module
            comment_str = <<END_OF_COMMENTS
! 
! WARNING:  This file was automatically generated by the #{@appname} script. 
! 
END_OF_COMMENTS
            ios.print comment_str
            ios.print "      MODULE #{@new_module}\n\n"
            ios.print "      IMPLICIT NONE\n"
            ios.print "      PUBLIC\n\n"
            matching_symbols.each do |sym|
              if (sym =~ /#{@symbol}/i) then
                new_name = sym.sub(/#{@symbol}/i,@new_symbol)
                ios.print "        USE #{@old_module}, only: #{new_name} => #{sym}\n"
              else
                # handle "operator", "assignment", etc.
                ios.print "        USE #{@old_module}, only: #{sym}\n"
              end
            end
            ios.print "\n        IMPLICIT NONE\n\n"
#            ios.print "  PRIVATE\n\n"
            ios.print "      END MODULE #{@new_module}\n"
          else
            # default behavior is to print out matching symbols
            ios.print "#{matching_symbols.join("\n")}\n"
          end
          if (@stdout_fname) then
            ios.close
          end
        else
          if (@verbose >= @@verbose_min) then
            print "Found no matching symbols!\n"
          end
        end
        else
        if (@verbose >= @@verbose_min) then
          print "\nWARNING:  Could not find any Fortran source files to search in directory \"#{@targetdir}\""
        end
      end
    end
  end

end  # class FindSymbol


# FindSymbol.new


